{"version":3,"sources":["js/task-2.js"],"names":["users","name","active","toggleUserState","allUsers","userName","updatedUsers","map","user","Promise","console","log","resolve","logger","table","then","fetchPokemonById","id","fetch","r","json","onFetchSuccess","pokemon","onFetchError","error","catch","makePromise","reject","passed","Math","random","setTimeout","result"],"mappings":";;;;;AA0HA,aA1HA,QAAA,wBACA,QAAA,iCAyBA,MAAMA,EAAQ,CACV,CAAEC,KAAM,QAASC,QAAQ,GACzB,CAAED,KAAM,OAAQC,QAAQ,GACxB,CAAED,KAAM,OAAQC,QAAQ,GACxB,CAAED,KAAM,MAAOC,QAAQ,IAErBC,EAAkB,CAACC,EAAUC,KACzBC,MAAAA,EAAeF,EACpBG,IAAIC,GACDA,EAAKP,OAASI,EACZ,IAAKG,EAAMN,QAASM,EAAKN,QACzBM,GAICC,OADPC,QAAQC,IAAIF,QAAQG,QAAQN,IACrBG,QAAQG,QAAQN,IAGrBO,EAASP,GAAgBI,QAAQI,MAAMR,GAE7CH,EAAgBH,EAAO,SAASe,KAAKF,GACrCV,EAAgBH,EAAO,OAAOe,KAAKF,GAuCnC,MAAMG,EAAmBC,GAChBC,2CAA2CD,KAAMF,KAAKI,GAAKA,EAAEC,QAStE,SAASC,EAAeC,GACtBZ,QAAQC,IAAI,oCACZD,QAAQC,IAAIW,GAGd,SAASC,EAAaC,GACpBd,QAAQC,IAAI,gCACZD,QAAQC,IAAI,qBACZD,QAAQC,IAAIa,GAddR,EAAiB,GAAGD,KAAKM,GAAgBI,MAAMF,GAE/CP,EAAiB,GAAGD,KAAKM,GAAgBI,MAAMF,GAE/CP,EAAiB,GAAGD,KAAKM,GAAgBI,MAAMF,GAc/C,MAAMG,EAAc,IACX,IAAIjB,QAAQ,CAACG,EAASe,KACrBC,MAAAA,EAASC,KAAKC,SAAW,GAE/BC,WAAW,KACLH,GACFhB,EAAQ,sBAGVe,EAAO,6BACN,OAIPD,IACGX,KAAKiB,GAAUtB,QAAQC,IAAIqB,IAC3BP,MAAMD,GAASd,QAAQC,IAAIa","file":"task-2.32c607fc.js","sourceRoot":"../src","sourcesContent":["import '../sass/_common.scss';\nimport '../sass/_promisification.scss';\n\n/*\n    ### 2\nПерепиши функцию `toggleUserState()` так, чтобы она не использовала callback-функцию callback, \nа принимала всего два параметра `allUsers` и `userName` и возвращала промис.\nconst users = [\n  { name: 'Mango', active: true },\n  { name: 'Poly', active: false },\n  { name: 'Ajax', active: true },\n  { name: 'Lux', active: false },\n];\nconst toggleUserState = (allUsers, userName, callback) => {\n  const updatedUsers = allUsers.map(user =>\n    user.name === userName ? { ...user, active: !user.active } : user,\n  );\n  callback(updatedUsers);\n};\nconst logger = updatedUsers => console.table(updatedUsers);\n    // Сейчас работает так\ntoggleUserState(users, 'Mango', logger);\ntoggleUserState(users, 'Lux', logger);\n*/\n\n    // ======== Answer ========\nconst users = [\n    { name: 'Mango', active: true },\n    { name: 'Poly', active: false },\n    { name: 'Ajax', active: true },\n    { name: 'Lux', active: false },\n];\nconst toggleUserState = (allUsers, userName) => {\n    const updatedUsers = allUsers\n    .map(user => \n        user.name === userName \n        ? { ...user, active: !user.active } \n        : user,\n    );\n\n    console.log(Promise.resolve(updatedUsers)); \n    return Promise.resolve(updatedUsers);\n};\n\nconst logger = updatedUsers => console.table(updatedUsers);\n\ntoggleUserState(users, 'Mango').then(logger);\ntoggleUserState(users, 'Lux').then(logger);\n\n\n/* ===================================\n * Промисификация:\n * - Поблема доступа к результату промиса с колбеком\n * - Функция которая возвращает промис\n */\n// const makeOrder = dish => {\n//   const DELAY = 1000;\n\n//   return new Promise((resolve, reject) => {\n//     const passed = Math.random() > 0.5;\n\n//     setTimeout(() => {\n//       if (passed) {\n//         resolve(`✅ Вот ваш заказ: ${dish}`);\n//       }\n\n//       reject('❌ Упс, у нас закончились продукты');\n//     }, DELAY);\n//   });\n// };\n\n// makeOrder('пирожок').then(onMakeOrderSuccess).catch(onMakeOrderError);\n\n// function onMakeOrderSuccess(result) {\n//   console.log('onMakeOrderSuccess');\n//   console.log(result);\n// }\n\n// function onMakeOrderError(error) {\n//   console.log('onMakeOrderError');\n//   console.log(error);\n// }\n\n/*\n * Покемоны с https://pokeapi.co/\n */\nconst fetchPokemonById = id => {\n  return fetch(`https://pokeapi.co/api/v2/pokemon/${id}`).then(r => r.json());\n};\n\nfetchPokemonById(1).then(onFetchSuccess).catch(onFetchError);\n  \nfetchPokemonById(2).then(onFetchSuccess).catch(onFetchError);\n\nfetchPokemonById(3).then(onFetchSuccess).catch(onFetchError);\n\nfunction onFetchSuccess(pokemon) {\n  console.log('onFetchSuccess -> onFetchSuccess');\n  console.log(pokemon);\n}\n\nfunction onFetchError(error) {\n  console.log('onFetchError -> onFetchError');\n  console.log('Это в блоке catch');\n  console.log(error);\n}\n\n// makePromise\nconst makePromise = () => {\n  return new Promise((resolve, reject) => {\n    const passed = Math.random() > 0.5;\n\n    setTimeout(() => {\n      if (passed) {\n        resolve('✅ Куку это resolve');\n      }\n\n      reject('❌ все пропало это reject');\n    }, 2000);\n  });\n};\n\nmakePromise()\n  .then(result => console.log(result))\n  .catch(error => console.log(error));"]}